@startuml
'https://plantuml.com/class-diagram
skinparam classAttributeIconSize 0
skinparam classFontStyle Bold
skinparam style strictuml
hide empty members

package javax.lang.model
{
    interface element.AnnotationMirror <<interface>>
    {
        +{abstract}getAnnotationType() : DeclaredType
        +{abstract}getElementValues() : Map<? extends ExecutableElement, ? extends AnnotationValue>
    }

    interface element.AnnotationValue <<interface>>
    {
        +{abstract}accept(v:AnnotationValueVisitor<R,P>, p:P) : <R, P> R
        +{abstract}getValue() : Object
        +{abstract}toString() : String
    }

    interface element.AnnotationValueVisitor<R,P> <<interface>>
    {
        + visit(av:AnnotationValue) : default R
        +{abstract}visit(av:AnnotationValue, p:P) : R
        +{abstract}visitAnnotation(a:AnnotationMirror, p:P) : R
        +{abstract}visitArray(vals:List<? extends AnnotationValue>, p:P) : R
        +{abstract}visitBoolean(b:boolean, p:P) : R
        +{abstract}visitByte(b:byte, p:P) : R
        +{abstract}visitChar(c:char, p:P) : R
        +{abstract}visitDouble(d:double, p:P) : R
        +{abstract}visitEnumConstant(c:VariableElement, p:P) : R
        +{abstract}visitFloat(f:float, p:P) : R
        +{abstract}visitInt(i:Integer, p:P) : R
        +{abstract}visitLong(i:long, p:P) : R
        +{abstract}visitShort(s:short, p:P) : R
        +{abstract}visitString(s:String, p:P) : R
        +{abstract}visitType(t:TypeMirror, p:P) : R
        +{abstract}visitUnknown(av:AnnotationValue, p:P) : R
    }
    interface element.Element <<interface>>
    {
        +{abstract}accept(v:ElementVisitor<R,P>, p:P) : <R, P>
        +{abstract}asType() : TypeMirror
        +{abstract}equals(obj:Object) : boolean
        +{abstract}getAnnotation(annotationType:Class<A>) : <A extends Annotation> A
        +{abstract}getAnnotationMirrors() : List<? extends AnnotationMirror>
        +{abstract}getAnnotationByType(annotationType:Class<A>) : <A extends Annotation> A[]
        +{abstract}getEnclosedElements() : List<? extends Element>
        +{abstract}getEnclosingElement() : Element
        +{abstract}getKind() : ElementKind
        +{abstract}getModifiers() : Set<Modifier>
        +{abstract}getSimpleName() : Name
        +{abstract}hashCode() : Integer
    }

    enum element.ElementKind <<enumération>>
    {
        ANNOTATION_TYPE
        BINDING_VARIABLE
        CLASS
        CONSTRUCTOR
        ENUM
        ENUM_CONSTANT
        EXCEPTION_PARAMETER
        FIELD
        INSTANCE_INIT
        INTERFACE
        LOCAL_VARIABLE
        METHOD
        MODULE
        OTHER
        PACKAGE
        PARAMETER
        RECORD
        RECORD_COMPONENT
        RESOURCE_VARIABLE
        STATIC_INIT
        TYPE_PARAMETER
        +isclass() : boolean
        +isDeclaredType() : boolean
        +isExecutable() : boolean
        +isField() : boolean
        +isInitializer() : boolean
        +isInterface() : boolean
        +isVariable() : boolean
        +{static}valueOf(name:String) : ElementKind
        +{static}values() : ElementKind[]
    }

    interface element.ElementVisitor<R,P> <<interface>>
    {
        + visit(e:Element) : default R
        +{abstract}visit(e:Element, p:P) : R
        +{abstract}visitExecutable(e:ExecutableElement, p:P) : R
        + visitModule(e:ModuleElement, p:P) : default R
        +{abstract}visitPackage(e:PackageElement, p:P) : R
        + visitRecordComponent(e:RecordComponentElement, p:P) : default R
        +{abstract}visitType(e:TypeElement, p:P) : R
        +{abstract}visitTypeParameter(e:TypeParameterElement, p:P) : R
        +{abstract}visitUnknown(e:Element, p:P) : R
        +{abstract}visitVariable(e:VariableElement, p:P) : R
    }

    interface element.ExecutableElement <<interface>>
    {
        +{abstract}asType() : TypeMirror
        +{abstract}getDefaultValue() : AnnotationValue
        +{abstract}getEnclosingElement() : Element
        +{abstract}getParameters() : List<? extends VariableElement>
        +{abstract}getReceiverType() : TypeMirror
        +{abstract}getReturnType() : TypeMirror
        +{abstract}getSimpleName() : Name
        +{abstract}getThrownTypes() : List<? extends TypeMirror>
        +{abstract}getTypeParameters() : List<? extends TypeParameterElement>
        +{abstract}isDefault() : boolean
        +{abstract}isVarArgs() : boolean
    }

    enum element.Modifier <<enumération>>
    {
        ABSTRACT
        DEFAULT
        FINAL
        NATIVE
        NON_SEALED
        PRIVATE
        PROTECTED
        PUBLIC
        SEALED
        STATIC
        STRICTFP
        SYNCHRONIZED
        TRANSIENT
        VOLATILE
        + toString() : String
        +{static}valueOf(name:String) : Modifier
        +{static}values() : Modifier[]
    }

    interface element.ModuleElement <<interface>>
    {
        +{static}interface ModuleElement.Directive
        +{static}enum ModuleElement.DirectiveKind
        +{static}interface ModuleElement.DirectiveVistitor<R,P>
        +{static}interface ModuleElement.ExportsDirective
        +{static}interface ModuleElement.OpensDirective
        +{static}interface ModuleElement.ProvidesDirective
        +{static}interface ModuleElement.RequiresDirective
        +{static}interface ModuleElement.UsesDirective
        +{abstract}asType() : TypeMirror
        +{abstract}getDirectives() : List<? extends ModuleElement.Directive>
        +{abstract}getEnclosedElements() : List<? extends Element>
        +{abstract}getEnclosingElement() : Element
        +{abstract}getQualifiedName() : Name
        +{abstract}getSimpleName() : Name
        +{abstract}isOpen() : boolean
        +{abstract}isUnnamed() : boolean
    }

    interface element.Name <<interface>>
    {
        +{abstract}contentEquals(cs : CharSequence) : boolean
        +{abstract}equals(obj:Object) : boolean
        +{abstract}hashCode() : Integer
    }

    enum element.NestingKind <<enumération>>
    {
        ANONYMOUS
        LOCAL
        MEMBER
        TOP_LEVEL
        + isNested() : boolean
        +{static}valueOf(name:String) : NestingKind
        +{static}values() : NestingKind[]
    }

    interface element.PackageElement <<interface>>
    {
        +{abstract}asType() : TypeMirror
        +{abstract}getEnclosedElements() : List<? extends Element>
        +{abstract}getEnclosingElement() : Element
        +{abstract}getQualifiedName() : Name
        +{abstract}getSimpleName() : Name
        +{abstract}isUnnamed() : boolean
    }

    interface element.Parameterizable <<interface>>
    {
        +{abstract}getTypeParameters() : List<? extends TypeParameterElement>
    }

    interface element.QualifiedNameable <<interface>>
    {
        +{abstract}getQualifiedName() : Name
    }

    interface element.RecordComponentElement <<interface>>
    {
        +{abstract}getAccessor() : ExecutableElement
        +{abstract}getEnclosingElement() : Element
        +{abstract}getSimpleName() : Name
    }

    interface element.TypeElement <<interface>>
    {
        +{abstract}asType() : TypeMirror
        +{abstract}getEnclosedElements() : List<? extends Element>
        +{abstract}getEnclosingElement() : Element
        +{abstract}getInterfaces() : List<? extends TypeMirror>
        +{abstract}getNestingKind() : NestingKind
        + getPermittedSubClasses() : default List<? extends TypeMirror>
        +{abstract}getQualifiedName() : Name
        + getRecordComponents() : default List<? extends RecordComponentElement>
        +{abstract}getSimpleName() : Name
        +{abstract}getSuperClass() : TypeMirror
        +{abstract}getTypeParameters() : List<? extends TypeParameterElement>
    }

    interface element.TypeParameterElement <<interface>>
    {
        +{abstract}asType() : TypeMirror
        +{abstract}getBounds() : List<? extends TypeMirror>
        +{abstract}getEnclosingElement() : Element
        +{abstract}getGenericElement() : Element
    }

    class element.UnknownAnnotationValueException
    {
        +<<create>>UnknownAnnotationValueException(av:AnnotationValue,p:Object)
        + getArgument() : Object
        + getUnknownAnnotationValue() : AnnotationValue
    }

    class element.UnknownDirectiveException
    {
        +<<create>>UnknownDirectiveException(d:ModuleElement.Directive,p:Object)
        + getArgument() : Object
        + getUnknownDirective() : ModuleElement.Directive
    }

    class element.UnknownElementException
    {
        +<<create>>UnknownElementException(e:Element,p:Object)
        + getArgument() : Object
        + getUnknownElement() : Element
    }

    interface element.VariableElement <<interface>>
    {
        +{abstract}asType() : TypeMirror
        +{abstract}getConstantValue() : Object
        +{abstract}getEnclosingElement() : Element
        +{abstract}getSimpleName() : Name
    }

    interface type.ArrayType <<interface>>
    {
        +{abstract}getComponentType() : TypeMirror
    }

    interface type.DeclaredType <<interface>>
    {
        +{abstract}asElement() : Element
        +{abstract}getEnclosingElement() : TypeMirror
        +{abstract}getTypeArguments() : List<? extends TypeMirror>
    }

    interface type.ErrorType <<interface>>

    interface type.ExecutableType <<interface>>
    {
        +{abstract}getParametersType() : List<? extends TypeMirror>
        +{abstract}getReceiverType() : TypeMirror
        +{abstract}getReturnType() : TypeMirror
        +{abstract}getThrownTypes() : List<? extends TypeMirror>
        +{abstract}getTypeVariables() : List<? extends TypeVariable>
    }

    interface type.IntersectionType <<interface>>
    {
        +{abstract}getBounds() : List<? extends TypeMirror>
    }

    class type.MirroredTypeException
    {
        +<<create>>MirroredTypeException(type:TypeMirror)
        + getTypeMirror() : TypeMirror
    }

    class type.MirroredTypesException
    {
        +<<create>>MirroredTypesException(types:List<? extends TypeMirror>)
        + getTypeMirror() : List<? extends TypeMirror>
    }

    interface type.NoType <<interface>>

    interface type.NullType <<interface>>

    interface type.PrimitiveType <<interface>>

    interface type.ReferenceType <<interface>>

    enum type.TypeKind <<enumération>>
    {
        ARRAY
        BOOLEAN
        BYTE
        CHAR
        DECLARED
        DOUBLE
        ERROR
        EXECUTABLE
        FLOAT
        INT
        INTERSECTION
        LONG
        MODULE
        NONE
        NULL
        OTHER
        PACKAGE
        SHORT
        TYPEVAR
        UNION
        VOID
        WILDCARD

        + isPrimitive() : boolean
        +{static}valueOf(name:String) : TypeKind
        +{static}values() : TypeKind[]
    }


}

@enduml